---
title: "Отключенные сущности - EF Core"
author: ajcvickers
ms.author: avickers
ms.date: 10/27/2016
ms.assetid: 2533b195-d357-4056-b0e0-8698971bc3b0
ms.technology: entity-framework-core
uid: core/saving/disconnected-entities
ms.openlocfilehash: 0ea02876b9594d54c971a7b70fcf7ce591e56ba0
ms.sourcegitcommit: ced2637bf8cc5964c6daa6c7fcfce501bf9ef6e8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="disconnected-entities"></a>Отключенные сущности

Экземпляр DbContext будет автоматически отслеживать сущностей, возвращаемых из базы данных. Изменения, внесенные в эти сущности будут обнаружены, затем при вызове SaveChanges и базы данных будут обновляться по мере необходимости. В разделе [основные Сохранить](basic.md) и [связанные данные](related-data.md) подробные сведения.

Тем не менее иногда сущности, в запросах с помощью одного контекста экземпляра, а затем сохраняется с помощью другого экземпляра. Это часто происходит в «отключенной» сценарии, такие как веб-приложения, где сущности запроса, отправляются на клиент, изменены, отправляются обратно на сервер в запросе и сохраняются. В этом случае контекст второго экземпляра знает, являются ли новые сущности (должен быть установлен) или в существующие (должны быть обновлены).

> [!TIP]  
> Для этой статьи вы можете скачать [пример](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/Saving/Saving/Disconnected/) из репозитория GitHub.

## <a name="identifying-new-entities"></a>Определение новых сущностей

### <a name="client-identifies-new-entities"></a>Клиент определяет новые сущности

При простом случае работать с клиента сообщает серверу, является ли сущность новой или существующей. Например часто запрос для вставки новой сущности отличается от запрос на обновление существующей сущности.

Далее в этом разделе описываются варианты где необходимо определить, каким-либо образом вставки или обновления.

### <a name="with-auto-generated-keys"></a>С помощью автоматически сформированных ключей

Значение автоматически созданного ключа часто может использоваться для определения, должна ли сущность вставлять или обновлять. Если ключ не задан, (т. е. он по-прежнему имеет значение CLR по умолчанию null, нуль, т. д.), то сущности должен быть новый и требуется вставить. С другой стороны Если значение ключа затем должен быть уже сохранен ранее и теперь требуется обновить. Другими словами Если ключ имеет значение, затем сущность запрос, отправляемый клиенту и теперь вернуться обновляться.

Это легко проверить для ключа не задано, когда известен тип сущности:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#IsItNewSimple)]

Однако EF также имеет встроенный способ сделать это для любого типа сущности и типа ключа.

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#IsItNewGeneral)]

> [!TIP]  
> Ключи задаются как можно скорее сущностей отслеживаются контекстом, даже если сущность находится в состоянии добавления. Это помогает при обходе графа сущностей и решить, что делать с каждой, например при использовании TrackGraph API. Значение ключа можно использовать только как показано здесь _перед_ любой вызов для отслеживания сущности.

### <a name="with-other-keys"></a>С другими ключами

Другой механизм необходим для идентификации новых сущностей, когда значения ключей не могут создаваться автоматически. Существует два принципиальных подхода к этому:
 * Запрос для сущности
 * Передайте флаг от клиента

Для выполнения запроса для сущности, просто используйте метод Find:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#IsItNewQuery)]

Он выходит за рамки настоящего документа показан полный код для передачи флаг от клиента. В веб-приложения это обычно означает выполнение различных запросов для различных действий или передача какое-либо состояние, в запросе, а затем извлечение его в контроллере.

## <a name="saving-single-entities"></a>Сохранение одной сущности

Если известно ли необходима инструкция insert или update, а затем добавить или обновить используется соответствующим образом:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#InsertAndUpdateSingleEntity)]

Тем не менее если автоматически сгенерированный ключевые значения используются сущности, метод Update можно использовать в обоих случаях:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#InsertOrUpdateSingleEntity)]

Метод обновления обычно помечает сущности для обновления, но не вставки. Тем не менее если сущность имеет автоматического создания ключа, а не значение ключа не задана, то сущность автоматически помечается для вставки.

> [!TIP]  
> Это поведение было введено в EF Core 2.0. Для более ранних выпусков всегда бывает необходимо явно выбрать добавить или обновить.

Если сущность не использует автоматически сформированные ключи, то приложения необходимо решить, следует ли вставлять или обновлять сущность: пример:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#InsertOrUpdateSingleEntityWithFind)]

Здесь необходимо:
* Если добавить Find возвращает null, а затем базы данных еще не содержит блогов с этим Идентификатором, поэтому мы называем его нужно пометьте для вставки.
* Если найти возвращает сущность, затем он существует в базе данных и контекст отслеживает существующей сущности
  * Затем мы используем SetValues задавать значения для всех свойств в этой сущности теми, которые поступили от клиента.
  * Вызов SetValues будут помечены как сущность, которая обновляется по мере необходимости.

> [!TIP]  
> SetValues только будут отмечены как измененные свойства, которые имеют разные значения в соответствующие Отслеживаемая сущность. Это означает, что при отправке обновления будут обновлены только те столбцы, которые действительно были изменены. (И если ничего не изменилось, то обновление не будут отправляться на всех).

## <a name="working-with-graphs"></a>Работа с диаграммами

### <a name="all-newall-existing-entities"></a>Все новые или все существующие сущности

Пример работы с диаграммами вставке или обновлении блога вместе с его коллекцию связанных записей. Если нужно вставить все сущности в графе или все должны быть обновлены, процесс является таким же, как описано выше для одной сущности. Например график блогов и сообщений, созданных следующим образом:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#CreateBlogAndPosts)]

можно вставить следующим образом:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#InsertGraph)]

Вызов Add отметит блогов и все сообщения для вставки.

Аналогично Если все сущности в виде графа, должны быть обновлены, то обновление может использоваться:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#UpdateGraph)]

Блог и все сообщения будут помечены обновляться.

### <a name="mix-of-new-and-existing-entities"></a>Сочетание новых и существующих сущностей

С автоматически формируемым ключам обновления снова используется для операций вставки и обновления, даже если диаграмма содержит набор сущностей, которые требуют вставки и те, которые требуется обновление:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#InsertOrUpdateGraph)]

Обновления будут отмечены все сущности в граф, блога или post для вставки, если не имеет набор значение ключа, пока все сущности, помечаются для обновления.

Как и прежде, если не используются автоматически сформированные ключи, запрос и некоторая обработка могут использоваться:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#InsertOrUpdateGraphWithFind)]

## <a name="handling-deletes"></a>Обработка удалений

Удаление может быть непростой задачей, для обработки с момента часто отсутствия сущности означает, он должен быть удален. Для решения этой проблемы можно использовать «мягкие удалений» таким образом, что объект помечен как удаленный вместо фактического удаления. Удаляет, а затем становится таким же, как обновления. Обратимых удалений можно реализовать с помощью [запрос фильтры](xref:core/querying/filters).

Значение true, удаления общий шаблон является использование расширение шаблона запроса для выполнения, возможности по существу graph сумм. Пример:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#InsertUpdateOrDeleteGraphWithFind)]

## <a name="trackgraph"></a>TrackGraph

Внутренне добавить, присоединить и Update использовать graph обхода с изменения, внесенные для каждой сущности, относительно ли он должен быть помечен как Added (вставляемый) Modified (для обновления), без изменений (ничего), или удаленных (для удаления). Этот механизм выполняется через TrackGraph API. Например предположим, что, когда клиент отправляет обратно графа сущностей его устанавливает некоторые флаг для каждой сущности, указывающее, как он обрабатывается. TrackGraph затем может использоваться для обработки этого флага:

[!code-csharp[Main](../../../samples/core/Saving/Saving/Disconnected/Sample.cs#TrackGraph)]

Флаги, отображаются только в составе сущности для простоты примера. Обычно указывается флаги часть DTO или какое-либо состояние, включенных в запрос.
