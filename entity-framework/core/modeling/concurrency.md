---
title: "Маркеры параллелизма - EF Core"
author: rowanmiller
ms.author: divega
ms.date: 10/27/2016
ms.assetid: bc8b1cb0-befe-4b67-8004-26e6c5f69385
ms.technology: entity-framework-core
uid: core/modeling/concurrency
ms.openlocfilehash: 6574a9098d38c4aa525ffb4896adb01082420b5f
ms.sourcegitcommit: 860ec5d047342fbc4063a0de881c9861cc1f8813
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2017
---
# <a name="concurrency-tokens"></a>Маркеры параллелизма

Если свойство настроено как маркер параллелизма затем EF будет проверять, что ни один другой пользователь изменил это значение в базе данных при сохранении изменений в этой записи. EF используется модель оптимистичного параллелизма, что означает, что будет предполагается, что значение не изменилось и попробуйте сохранить данные, но создавать, если он обнаруживает, что значение было изменено.

Например необходимо настроить `LastName` на `Person` быть маркера параллелизма. Это означает, что если один пользователь пытается сохранить некоторые изменения в `Person`, но другой пользователь изменил `LastName` , то будет вызвано исключение. Это может быть нежелательно, чтобы ваше приложение может запрашивать у пользователя, чтобы убедиться, что эта запись по-прежнему представляет же реальный пользователь перед сохранением изменений.

> [!NOTE]
> Этой странице приведены инструкции по настройке маркеры параллелизма. В разделе [обработки параллелизма](../saving/concurrency.md) примеры использования оптимистичного параллелизма в приложении.

## <a name="how-concurrency-tokens-work-in-ef"></a>Как работают маркеры параллелизма в EF

Хранилища данных можно принудительно задать маркеры параллелизма, проверьте, что все записи в обновляемой или удаляемой по-прежнему имеет то же значение для маркер параллелизма, назначенный при контекст начальной загрузки данных из базы данных.

Например, реляционных баз данных для этого можно маркер параллелизма, в том числе `WHERE` предложение любого `UPDATE` или `DELETE` команды и выполняется проверка номера строк, которые были затронуты. Если маркер параллелизма по-прежнему соответствует одной строке обновляются. При изменении значения в базе данных, строки не обновляются.

```sql
UPDATE [Person] SET [FirstName] = @p1
WHERE [PersonId] = @p0 AND [LastName] = @p2;
```

## <a name="conventions"></a>Соглашения

По соглашению свойства никогда не настроен как маркеры параллелизма.

## <a name="data-annotations"></a>Заметки к данным

Заметки данных можно использовать для настройки свойства в качестве маркера параллелизма.

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Samples/Concurrency.cs#ConfigureConcurrencyAnnotations)]

## <a name="fluent-api"></a>Fluent API

Fluent API можно использовать для настройки свойства в качестве маркера параллелизма.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Samples/Concurrency.cs#ConfigureConcurrencyFluent)]

## <a name="timestamprow-version"></a>Отметка времени или строки версии

Отметки времени — это свойство, когда новое значение создается в базе данных каждый раз при вставке или обновлении строки. Свойство также рассматриваются как маркер параллелизма. Это гарантирует, что если кто-то еще изменил строка, которую вы пытаетесь обновить, так как запросы для данных, будет вызвано исключение.

Как это можно сделать, зависит от используемого поставщика базы данных. Отметка времени обычно используются для SQL Server на *byte []* свойство, которое будет настроить как *ROWVERSION* столбца в базе данных.

### <a name="conventions"></a>Соглашения

По соглашению свойства никогда не настроен как отметки времени.

### <a name="data-annotations"></a>Заметки к данным

Заметок к данным можно использовать для настройки свойства в качестве метки времени.

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Samples/Timestamp.cs#ConfigureTimestampAnnotations)]

### <a name="fluent-api"></a>Fluent API

Fluent API можно использовать для настройки свойства в качестве метки времени.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Samples/Timestamp.cs#ConfigureTimestampFluent)]
